# java类加载

---
### 虚拟机类加载机制
Java实现语言无关性的基础是虚拟机和字节码的存储格式。  
Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。  
虚拟机不关心Class文件的来源是什么语言。  
Java技术一直保持着非常良好的向后兼容性，Class文件结构的稳定功不可没。尽管不同版本的《Java虚拟机规范》对Class文件格式进行了几次的更新，但基本上只是在原有结构基础上新增内容、扩充功能，并未对已定义的内容做出修改。  
Class文件是一组以8个字节码为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件中，中间没有添加任何分隔符。  
关于Class二级制文件结构的详细解析，可以查看《深入理解Java虚拟机》第三部分第6章关于类文件结构的讲解。

#### 概述
Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成了可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。  
与那些编译时需要连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但时却为Java应用提供了极高的扩展性和灵活性，Java语言天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。  
例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义的类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为程序代码的一部分。

#### 类加载的时机
一个类从被加载到虚拟机内存中开始，到卸载出内存为止，他的整个生命周期将经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析三个部分统称为连接。  
加载、验证、准备、解析、初始化和卸载这五个阶段的顺序是确定的，解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性。

**加载**  
（1）通过一个类的全限定名来获取定义此类的二级制字节流。  
（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  
（3）在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

这句话说了三个意思，可以从本地、网络、压缩包、加密文件、数据库等读取.class二进制文件。在堆上生成的这个类的Class对象，在方法区存储了类的元数据信息、静态变量、即时编译器编译后的代码。通过这个Class对象访问方法区各种数据。

**验证**  
验证是连接的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。  
一共包含四个阶段：

1. 文件格式验证。  
   这个阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流。
2. 元数据验证。  
   对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。
3. 字节码验证。  
   主要目的是通过数据流分析和控制流分析，确定程序语义是合法、符合逻辑的。
4. 符号引用验证  
   最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
**准备**
准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。  
从概念上讲，这些变量所使用的内存都应该在方法区中进行分配，但必须注意方法区本身是一个逻辑上的区域，JDK1.7及以前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK1.8及以后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种逻辑概念的表述了。  
这个时候进行内存分配的仅包括类变量，不包括实例变量，通常情况类变量初始值为各数据类型零值，但如果类字段属性表中存在ConstantValue属性，及被static final修饰，那么在准备阶段就会被初始化为指定值。static final通常表示常量属性。

**解析**
将常量池内的符号引用替换为直接引用的过程。

**初始化**
初始化就是执行类构造器`<clinit>()`方法的过程。  
`<clinit>()`方法是编译器自动收集类中的所有类变量的赋值动作和静态语句块`(static{})`中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

注意`<clinit>()`方法执行顺序
```java
public class Test1 {
   public static int a = 1;

   static {
              a = 2;
   }

   public static void main(String[] args) {
      System.out.println(Test1.a);//输出结果：2
   }
}
```
```java
public class Test2 {
   static {
              a = 2;
   }
   public static int a = 1;


   public static void main(String[] args) {
      System.out.println(Test2.a);//输出结果：1
   }
}
```
非法向前引用
```java
public class Test {
   static {
              i = 2;//可以赋值
      System.out.println(i);//Illegal forward reference（编译器会提示“非法向前引用”）
   }

   static int i = 1;
}
```
`<clinit>()`方法与类的构造函数不同（及在虚拟机视角的实例构造器`<init>()`方法）不同，它不需要显式的调用父类构造器，Java虚拟机会保证子类的`<clinit>()`方法执行前，父类的`<clinit>()`方法已经执行完毕。因此Java虚拟机中第一个被执行的`<clinit>()`方法类型肯定是java.lang.Object。

由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
```java
public class Test {
   public static void main(String[] args) {
      System.out.println(Child.b);//输出结果：2
   }
}

class Parent {
   public static int a = 1;

   static {
              a = 2;
   }
}

class Child extends Parent {
   public static int b = a;
}
```

Java虚拟机必须保证一个类的`<clinit>()`方法进行了加锁同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其它线程必须阻塞等待。

---
参考文章：  
[Java_Basic_Introduction/类加载器.md at master · JackChan1999/Java_Basic_Introduction · GitHub](https://github.com/JackChan1999/Java_Basic_Introduction/blob/master/第10章 反射机制/类加载器.md)